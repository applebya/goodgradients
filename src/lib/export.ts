import type { Gradient, Animation, GradientType, ExportResult } from '@/types';
import { transformGradient } from './gradient';

/**
 * Generate clean vanilla CSS export
 */
export function exportVanillaCSS(
  gradient: Gradient,
  type: GradientType,
  angle: number,
  animation?: Animation
): ExportResult {
  const cssGradient = transformGradient(gradient.gradient, type, angle);

  let code = `/* ${gradient.name} */
/* ${gradient.description} */

.gradient {
  background: ${cssGradient};
}`;

  if (animation) {
    code += `

/* ${animation.name} Animation */
${animation.keyframes}

.gradient-animated {
  background: ${cssGradient};
  ${animation.property}
}`;
  }

  // Add browser compatibility note for conic gradients
  if (type === 'conic') {
    code += `

/* Note: conic-gradient has ~94% browser support.
   For older browsers, consider a linear fallback. */`;
  }

  return {
    format: 'css',
    code,
    language: 'css',
  };
}

/**
 * Generate Tailwind CSS export with arbitrary values
 */
export function exportTailwind(
  gradient: Gradient,
  type: GradientType,
  angle: number,
  animation?: Animation
): ExportResult {
  const colors = gradient.colors;

  // Build the gradient class based on type
  let gradientClass: string;
  let styleNote = '';

  if (type === 'radial') {
    // Radial requires custom CSS or plugin
    gradientClass = `bg-[radial-gradient(circle_at_center,${colors.join(',').replace(/#/g, '%23')})]`;
    styleNote = `<!-- Radial gradient - use inline style for better compatibility -->
<div style="background: radial-gradient(circle at center, ${colors.join(', ')})"></div>

<!-- Or with Tailwind arbitrary value (encode # as %23): -->`;
  } else if (type === 'conic') {
    gradientClass = `bg-[conic-gradient(from_${angle}deg_at_center,${colors.join(',').replace(/#/g, '%23')})]`;
    styleNote = `<!-- Conic gradient - use inline style for better compatibility -->
<div style="background: conic-gradient(from ${angle}deg at center, ${colors.join(', ')})"></div>

<!-- Or with Tailwind arbitrary value (encode # as %23): -->`;
  } else {
    // Linear gradient - most common case
    if (colors.length === 2) {
      // Simple two-color gradient
      const fromColor = colors[0]?.replace('#', '') ?? '';
      const toColor = colors[1]?.replace('#', '') ?? '';
      gradientClass = `bg-gradient-to-br from-[#${fromColor}] to-[#${toColor}]`;
    } else {
      // Multi-color gradient
      gradientClass = `bg-[linear-gradient(${angle}deg,${colors.join(',').replace(/#/g, '%23')})]`;
    }
  }

  let code = `<!-- ${gradient.name} -->
${styleNote}
<div class="${gradientClass}">
  <!-- Your content -->
</div>`;

  if (animation) {
    code += `

<!-- With animation (add to your CSS): -->
<style>
${animation.keyframes}
</style>

<div class="${gradientClass}" style="${animation.property.replace('animation:', 'animation:')}">
  <!-- Animated content -->
</div>`;
  }

  return {
    format: 'tailwind',
    code,
    language: 'html',
  };
}

/**
 * Generate AI-friendly description for Claude/ChatGPT
 */
export function exportAIDescription(
  gradient: Gradient,
  type: GradientType,
  angle: number,
  animation?: Animation
): ExportResult {
  const colors = gradient.colors.join(' → ');
  const typeLabel = type.charAt(0).toUpperCase() + type.slice(1);

  let description = `Gradient: "${gradient.name}"
Type: ${typeLabel}${type !== 'radial' ? ` at ${angle}°` : ''}
Colors: ${colors}
Style: ${gradient.description}
Category: ${gradient.category}`;

  if (animation) {
    description += `

Animation: "${animation.name}"
Effect: ${animation.description}
Category: ${animation.category}`;
  }

  description += `

Use this for: ${gradient.tags.join(', ')}`;

  return {
    format: 'ai',
    code: description,
    language: 'text',
  };
}

/**
 * Generate all export formats
 */
export function generateAllExports(
  gradient: Gradient,
  type: GradientType,
  angle: number,
  animation?: Animation
): ExportResult[] {
  return [
    exportVanillaCSS(gradient, type, angle, animation),
    exportTailwind(gradient, type, angle, animation),
    exportAIDescription(gradient, type, angle, animation),
  ];
}

/**
 * Generate a downloadable CSS file content
 */
export function generateCSSFile(
  gradient: Gradient,
  type: GradientType,
  angle: number,
  animation?: Animation
): string {
  const result = exportVanillaCSS(gradient, type, angle, animation);
  return `/**
 * Generated by GoodGradients
 * https://goodgradients.com
 *
 * Gradient: ${gradient.name}
 * Created: ${new Date().toISOString().split('T')[0]}
 */

${result.code}
`;
}
